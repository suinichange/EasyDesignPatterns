## 观察者模式

### 概念

　　观察者模式又叫做发布－订阅（ Publish／ Subscribe）模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

### 观察者模式结构图

　　![观察者模式结构图](https://github.com/suinichange/EasyDesignPatterns/blob/master/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg)

　　Subject类，它把所有对观察者对象的引用保存在一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。

　　Observer类，抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个 Update方法，这个方法叫做更新方法。

　　ConcreteSubject类，叫做具体主题或具体通知者，将有关状态存入具体现察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。

　　ConcreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一个具体子类实现。

　　本章案例代码：[老板回来，好好工作](https://github.com/suinichange/EasyDesignPatterns/tree/master/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/ObserverPattern/src/com)

### 观察者模式解析

　　**为什么要用**？

　　将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都帯来不便。

　　因此引入观察者模式，来解决当一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

　　**什么时候用**？

　　当一个对象的改变需要同时改变其他对象的时候。而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。

　　当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。

　　**优点**？

　　观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象而不是依赖于具体。从而使得各自的变化都不会影响另一边的変化。
